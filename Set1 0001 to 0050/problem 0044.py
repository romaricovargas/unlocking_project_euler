'''
Problem 44
PENTAGON NUMBERS

Pentagon numbers are generated by the formula P(n) = n(3n-1)/2. 
The first ten pentagonal numbers are:

    1, 5, 12, 22, 35, 51, 70, 92, 117, 145 ...

It can be seen that P(4) + P(1) = 22 + 70 = 92 = P(8). 
However, their difference, 70-22=48, is not pentagonal.
Find the pair of pentagonal numbers, P(j) and P(k) for which 
their sum and difference are pentagonal and D = |P(k) - P(j)| is minimised; 
what is the value of D?

~ ~ ~ ~ ~ ~ ~ ~ ~ ~

Formula for checking if a number is pentagonal:

n = (sqrt((24*P)+1) + 1) / 6, if n is whole number then P is pentagonal

source: https://en.wikipedia.org/wiki/Pentagonal_number

~ ~ ~ ~ ~ ~ ~ ~ ~ ~

This is the algorithm I formulated. 
There are 2 checkings in every iteration which made the process 2x faster.

 - Orderly generate pairs of pentagonals
 - Check if the sum of 2 pentagonals P(m) and P(n) is also pentagonal P(s)
 - If P(s) is pentagonal, then P(s) - P(n) = P(m), the difference is pentagonal
 - If P(s) is pentagonal, then P(s) - P(m) = P(n), the difference is pentagonal
 - If the sum of P(s) and P(n) is pentagonal P(s1), then P(s) and P(n) is the desired pair
 - If the sum of P(s) and P(m) is pentagonal P(s2), then P(s) and P(m) is the desired pair

'''

from math import sqrt 

def problem_0044(limit=2000):
    pentagonal = {1:1}              # dictionary of pentagonal numbers {n1:P1, n2:P2}, with initial first entry. ex: {1:1, 2:5, 3:12}
    n = 2                           # initial n
    answer_found = False            # flag to indicate if answer is found

    def compute_pentagonal(x):
        return int(x*((3*x)-1)/2)
    
    def check_pentagonal(y):                 # y is the number being tested if pentagonal
        z = (sqrt((24*y)+1) + 1) / 6         # Use formula for checking if a number is pentagonal 
        if int(z) == z:
            return True
        return False

    while len(pentagonal) < limit and not answer_found:      # iterate from n=2 until answer is found or limit is reached
        pentagonal[n] = compute_pentagonal(n)                # compute pentagonal P(n)      

        for m in range(n-1, 0, -1):                          # iterate to all numbers lower than n from n-1 to 1, designated as m
            Ps = pentagonal[n] + pentagonal[m]               # get sum of pentagonals P(n) and P(m)
            if check_pentagonal(Ps):                         # check if sum is pentagonal P(s)
                Ps1 = pentagonal[n] + Ps                     # get sum1 of pentagonals P(s) and P(n)
                Ps2 = pentagonal[m] + Ps                     # get sum2 of pentagonals P(s) and P(m)
                if check_pentagonal(Ps1):                    # check if sum1 is pentagonal P(s1)
                    print("answer found")
                    print("n:     ", n)
                    print("P(n):  ", pentagonal[n])
                    print("P(s):  ", Ps)
                    print("diff:  ", abs(pentagonal[n]-Ps))
                    answer_found = True                      # set flag to true
                if check_pentagonal(Ps2):                    # check if sum2 is pentagonal P(s2)
                    print("answer found")
                    print("m:     ", m)
                    print("P(m):  ", pentagonal[m])
                    print("P(s):  ", Ps)
                    print("diff:  ", abs(pentagonal[m]-Ps))
                    answer_found = True                      # set flag to true
        n += 1

problem_0044(20000)